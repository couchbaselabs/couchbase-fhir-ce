FHIR Resource Creation and Transaction Processing
Overview
FHIR (Fast Healthcare Interoperability Resources) enables interoperability through a RESTful API model. Clients can create, update, or partially update resources using HTTP methods. It also supports grouped operations using bundles—primarily batch and transaction types.
HTTP Methods: POST, PUT, PATCH
POST
Purpose: Create a new resource without a client-supplied ID.
Endpoint: POST [base]/[resourceType]
Behavior: Server assigns a unique ID and returns 201 Created with the resource location.
Example:
POST /fhir/Patient
Content-Type: application/fhir+json

{
  "resourceType": "Patient",
  "name": [{"family": "Smith", "given": ["John"]}]
}


PUT
Purpose: Create or fully replace a resource at a specific logical ID.
Endpoint: PUT [base]/[resourceType]/[id]
Behavior:
Creates if the resource doesn’t exist.
Replaces the entire existing resource.
Example:
PUT /fhir/Patient/123
Content-Type: application/fhir+json

{
  "resourceType": "Patient",
  "id": "123",
  "name": [{"family": "Doe", "given": ["Jane"]}]
}


PATCH
Purpose: Partially update a resource.
Endpoint: PATCH [base]/[resourceType]/[id]
Behavior: Modifies only the fields specified.
Example (FHIR JSON Patch):
PATCH /fhir/Patient/123
Content-Type: application/json-patch+json

[
  { "op": "replace", "path": "/active", "value": false }
]


Bundle Types: Batch vs Transaction
FHIR allows grouping of operations into a Bundle resource with type: batch or type: transaction.
Batch Bundles
Type: batch
Processing: Independent HTTP requests.
Order: Unordered; server may process in any order.
Failure Handling: One failing entry does not affect others.
Use Case: Parallel processing of unrelated operations.
Transaction Bundles
Type: transaction
Processing: Entire bundle is a single atomic operation.
Order: Processed in order of entries.
Failure Handling: Entire transaction fails if any entry fails.
Use Case: Creation of related resources with references.
Feature
Batch
Transaction
Atomic
No
Yes
Reference Integrity
Not enforced
Enforced
Ordering
Arbitrary
Preserved

Transaction Bundle Structure and Processing
A Bundle with type: transaction includes entries with:
fullUrl (optional): For internal references
resource: The resource to act upon
request:
method: POST, PUT, DELETE, PATCH
url: Relative endpoint (e.g., Patient or Observation/123)
Internal Referencing with urn: URIs
Resources within a transaction bundle can reference each other using urn:uuid: or urn:oid: URIs. This is essential for maintaining referential integrity when creating multiple interrelated resources.
Example:
{
  "resourceType": "Bundle",
  "type": "transaction",
  "entry": [
    {
      "fullUrl": "urn:uuid:org1",
      "resource": {
        "resourceType": "Organization",
        "name": "Test Org"
      },
      "request": {
        "method": "POST",
        "url": "Organization"
      }
    },
    {
      "resource": {
        "resourceType": "Patient",
        "name": [{"family": "Doe", "given": ["Jane"]}],
        "managingOrganization": {
          "reference": "urn:uuid:org1"
        }
      },
      "request": {
        "method": "POST",
        "url": "Patient"
      }
    }
  ]
}


Transaction Response
The response bundle (type: transaction-response) includes each entry's status and new Location header if applicable.
Transaction Integrity Rules
FHIR specifies strong integrity requirements for transaction bundles:
Atomicity
All operations must succeed for the transaction to commit.
If one fails, the server must roll back all changes.
Reference Resolution
All internal references (e.g., urn:uuid:xxx) must be resolvable within the bundle.
Server must resolve and replace temporary URNs with real resource URLs.
Uniqueness of fullUrl
Each fullUrl in a transaction bundle must be unique.
Used for internal reference substitution.
Method Restrictions
Methods allowed: POST, PUT, PATCH, DELETE.
Each entry must contain a valid request.method and request.url.
Ordering and Dependencies
Resources are processed in order.
Dependencies (e.g., a Patient referencing an Organization) must appear after the resource they depend on or use internal urn: references.
StructureDefinition: Resource and DomainResource
FHIR uses the StructureDefinition resource to define the structure, constraints, and extensions of all resource types.
Resource
Base abstract type.
Includes common fields: id, meta, implicitRules, language.
DomainResource
Subclass of Resource.
Adds elements: text, contained, extension, modifierExtension.
Used when additional narrative or extensibility is required.
Custom Profiles
Organizations can define custom constraints or extensions by creating a new StructureDefinition and setting derivation = constraint.
FHIR References and By-Reference Semantics
By-Reference Model
FHIR enforces a by-reference rather than by-value data model:
Resources refer to each other using Reference objects.
A Reference includes a reference field pointing to the target resource’s canonical URL or relative path.
Example:
{
  "resourceType": "Observation",
  "subject": {
    "reference": "Patient/123"
  }
}


Not Embedded Documents
Resources do not embed full child resources inline.
Promotes modularity, reuse, and separation of resource lifecycles.
Contained Resources (Exception)
Resources can include contained resources in special cases.
These are inline definitions with no independent lifecycle.
Used when the referenced resource is not reusable or shareable.
Example:
{
  "resourceType": "MedicationRequest",
  "medication": {
    "reference": "#med1"
  },
  "contained": [
    {
      "resourceType": "Medication",
      "id": "med1",
      "code": {
        "text": "Amoxicillin 500mg"
      }
    }
  ]
}
